"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7482],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),u=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=u(e.components);return o.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=u(t),d=r,f=h["".concat(l,".").concat(d)]||h[d]||c[d]||i;return t?o.createElement(f,a(a({ref:n},p),{},{components:t})):o.createElement(f,a({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var u=2;u<i;u++)a[u]=t[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8341:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var o=t(7462),r=(t(7294),t(3905));const i={slug:"c-puzzles",title:"C Puzzles Part 1",author:"Jose Vargas",author_title:"Engineer",author_url:"https://github.com/josedvq",author_image_url:"https://avatars0.githubusercontent.com/u/1315101?s=400&v=4",tags:["c","puzzles","programming puzzles"]},a=void 0,s={permalink:"/blog/c-puzzles",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/blog/blog/2013-08-31-c-puzzles.md",source:"@site/blog/2013-08-31-c-puzzles.md",title:"C Puzzles Part 1",description:"The C Puzzles by Gowri Kumar are fifty C language programs meant to be compiled, run and explained. It's a great resource for those who are learning C. You'll learn the most if you use this post to compare with your own answers.",date:"2013-08-31T00:00:00.000Z",formattedDate:"August 31, 2013",tags:[{label:"c",permalink:"/blog/tags/c"},{label:"puzzles",permalink:"/blog/tags/puzzles"},{label:"programming puzzles",permalink:"/blog/tags/programming-puzzles"}],readingTime:18.48,hasTruncateMarker:!1,authors:[{name:"Jose Vargas",title:"Engineer",url:"https://github.com/josedvq",imageURL:"https://avatars0.githubusercontent.com/u/1315101?s=400&v=4"}],frontMatter:{slug:"c-puzzles",title:"C Puzzles Part 1",author:"Jose Vargas",author_title:"Engineer",author_url:"https://github.com/josedvq",author_image_url:"https://avatars0.githubusercontent.com/u/1315101?s=400&v=4",tags:["c","puzzles","programming puzzles"]},prevItem:{title:"Responsive CSS triangles",permalink:"/blog/responsive-css-triangles"},nextItem:{title:"Getting started with Icarus Verilog on Windows",permalink:"/blog/getting-started-icarus-verilog"}},l={authorsImageUrls:[void 0]},u=[],p={toc:u};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{href:"http://www.gowrikumar.com/c/",title:"Go to Gowri Kumar's website"},"C Puzzles")," by Gowri Kumar are fifty C language programs meant to be compiled, run and explained. It's a great resource for those who are learning C. You'll learn the most if you use this post to compare with your own answers."),(0,r.kt)("p",null,"I took the time to understand and answer the first 25 problems. I'm not a C programmer (just know the basics) but did my best to explain each program both from my knowledge and googling for answers. Don't believe these are the correct answers as they may in fact be wrong. Most of the C puzzles answers may be found on different forums and Q&A sites but were not gathered on a single place before. Hope it helps. Please leave feedback and let me know any errors you find using the comments at the end of the page."),(0,r.kt)("ol",null,(0,r.kt)("li",null,"The expected output of the following C program is to print the elements in the array. But when actually run, it doesn't do so.",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\n#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))\nint array[] = {23,34,12,17,204,99,16};\nint main(){\n    int d;\n    for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)\n        printf("%d\\n",array[d+1]);\n    return 0;\n}\n')),(0,r.kt)("p",null,"Find out what's going wrong."),(0,r.kt)("strong",null,"A:")," The for loop is not being executed. ",(0,r.kt)("code",null,"TOTAL_ELEMENTS")," is of type size_t which is unsigned. ",(0,r.kt)("code",null,"d")," is of type signed int. When an operator has a signed and an unsigned argument, and the unsigned argument is of greater or equal size to the signed argument, then the signed argument is converted to unsigned. So -1 is converted to 2^32 - 1 which of course is larger than ",(0,r.kt)("code",null,"TOTAL_ELEMENTS - 2"),". The comparisson is false. Forcing conversion to signed int with",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"for(d=-1;d <= (signed int)(TOTAL_ELEMENTS-2);d++)\n")),(0,r.kt)("p",null,"makes it work as expected.")),(0,r.kt)("li",null,"I thought the following program was a perfect C program. But on compiling, I found a silly mistake. Can you find it out (without compiling the program :-) ?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include<stdio.h>\n\nvoid OS_Solaris_print()\n{\n    printf("Solaris - Sun Microsystems\\n");\n}\n\nvoid OS_Windows_print()\n{\n    printf("Windows - Microsoft\\n");\n\n}\nvoid OS_HP-UX_print()\n{\n    printf("HP-UX - Hewlett Packard\\n");\n}\n\nint main()\n{\n    int num;\n    printf("Enter the number (1-3):\\n");\n    scanf("%d",&num);\n    switch(num)\n    {\n        case 1:\n            OS_Solaris_print();\n            break;\n        case 2:\n            OS_Windows_print();\n            break;\n        case 3:\n            OS_HP-UX_print();\n            break;\n        default:\n            printf("Hmm! only 1-3 :-)\\n");\n            break;\n    }\n\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," There's a dash in the function name ",(0,r.kt)("code",null,"void OS_HP-UX_print()"),". C does not accept dashes in function names. It must be deleted or changed by an underscore for the program to work."),(0,r.kt)("li",null,"What's the expected output for the following program and why?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'enum {false,true};\n\nint main()\n{\n    int i=1;\n    do\n    {\n        printf("%d\\n",i);\n        i++;\n        if(i < 15)\n            continue;\n    }while(false);\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," Output: 1 The continue statement passes control to the next iteration of the nearest enclosing do, for, or while statement in which it appears. Within a do or a while statement, the next iteration starts by reevaluating the expression of the do or while statement. In this case, the expression is false so there are no more iterations."),(0,r.kt)("li",null,'The following program doesn\'t "seem" to print "hello-out". (Try executing it)',(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\n#include <unistd.h>\nint main()\n{\n    while(1)\n    {\n        fprintf(stdout,"hello-out");\n        fprintf(stderr,"hello-err");\n        sleep(1);\n    }\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:"),' What is sent to stdout is kept in a buffer and is printed until a newline is sent. If the program ends without sending a newline to stdout nothing is printed. What is sent to stderr is printed immediatly. That\'s why just "hello-err" is printed. Change "hello-out" for "hello-out\\n" to print it.'),(0,r.kt)("li",null,"Consider the following:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\n#define f(a,b) a##b\n#define g(a)   #a\n#define h(a) g(a)\n\nint main()\n{\n    printf("%s\\n",h(f(1,2)));\n    printf("%s\\n",g(f(1,2)));\n    return 0;\n}\n')),(0,r.kt)("p",null,'Just by looking at the program one "might" expect the output to be the same for both the printf statements. But on running the program you get it as:\n12\nf(1,2)'),(0,r.kt)("strong",null,"A:"),' The definitions at the beggining are macros, read by the C preprocesor. The transforming or "evaluating" of a macro into a sequence is known as expansion. The parameter of a function-like macro is expanded unless it is the operand # or ##. Because g\'s parameter is the operand #, the argument is not expanded but instead immediately stringified "f(1,2)". Because h\'s parameter is not the operand # nor ##, the argument f(1,2) is expanded (12), then substituted (g(12)). Then the code is rescanned and further expansion occurs ("12").',(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://stackoverflow.com/questions/4364971/and-in-macros"},"stackoverflow.com/questions/4364971/and-in-macros"))),(0,r.kt)("li",null,"Consider the following:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include<stdio.h>\nint main()\n{\n    int a=10;\n    switch(a)\n    {\n        case \'1\':\n            printf("ONE\\n");\n            break;\n        case \'2\':\n            printf("TWO\\n");\n            break;\n        defa1ut:\n            printf("NONE\\n");\n    }\n    return 0;\n}\n')),(0,r.kt)("p",null,"If you expect the output of the above program to be NONE, I would request you to check it out!!"),(0,r.kt)("strong",null,"A:"),' The program doesn\'t print anything because the switch has no default case. It says "defau1t", not "default" so it is simply ignored. It is not a syntax error as it is treated as a normal ',(0,r.kt)("a",{href:"http://msdn.microsoft.com/en-us/library/2c002fdz.aspx"},"C label"),"."),(0,r.kt)("li",null,"The following C program segfaults on IA-64, but works fine on IA-32.",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int main()\n{\n    int* p;\n    p = (int*)malloc(sizeof(int));\n    *p = 10;\n    return 0;\n}\n")),(0,r.kt)("p",null,"Why does it happen so?"),(0,r.kt)("strong",null,"A:")," It happens because on IA-64 a pointer takes up 64 bits, more than an integer (32 bits). Without the header file stdlib.h the return type of malloc is assumed to be integer, not pointer (int is the default return type in C). The returned 64 bits are truncated to 32 and then the line ",(0,r.kt)("code",null,"p = (int*)malloc(sizeof(int));")," casts it to a 64 bit pointer. This, of course, damages the pointer causing a segfault when trying to write. Add stdlib.h to tell C to expect a pointer returned from malloc and fix the problem."),(0,r.kt)("li",null,"Here is a small piece of program(again just 14 lines of program) which counts the number of bits set in a number.",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input   Output\n0   0(0000000)\n5   2(0000101)\n7   3(0000111) \n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int CountBits (unsigned int x )\n{\n    static unsigned int mask[] = { 0x55555555,\n        0x33333333,\n        0x0F0F0F0F,\n        0x00FF00FF,\n        0x0000FFFF\n    };\n\n    int i ;\n    int shift ; /* Number of positions to shift to right*/\n    for ( i =0, shift =1; i < 5; i ++, shift *= 2)\n        x = (x & mask[i ])+ ( ( x >> shift) & mask[i]);\n    return x;\n}\n")),(0,r.kt)("p",null,"Find out the logic used in the above program."),(0,r.kt)("strong",null,"A:"),' This algorithm counts the number of ones in a number in binary. It does so by "dividing" the original number in pairs of bits and adding both bits of each pair. It keeps adding the results until there are no more groups to add. For example, for 11010101:',(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"| 1 + 1 | 0 + 1 | 0 + 1 | 0 + 1 |  \n|  1 0  +  0 1  |  0 1  +  0 1  |  \n|    0 0 1 1    +    0 0 1 0    |  \n|        0 0 0 0 0 1 0 1        |\n")),(0,r.kt)("p",null,"The code given doesn't look as intuitive because it uses masks to add the groups of bits, optimizing the number of operations. Take, for example, the first iteration. The first mask is 0x55555555 = 01010101...0101 The logical AND of this mask and x ",(0,r.kt)("code",null,"(x & mask","[1]",")")," makes zero all odd positions of x:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  1 1 0 1 0 1 0 1\n& 0 1 0 1 0 1 0 1\n= 0 1 0 1 0 1 0 1\n")),(0,r.kt)("p",null,"Shifting x to the right and then applying the mask to get ",(0,r.kt)("code",null,"((x >> shift) & mask","[1]",")")," makes zero all even positions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  1 1 1 0 1 0 1 0\n& 0 1 0 1 0 1 0 1\n= 0 1 0 0 0 0 0 0\n")),(0,r.kt)("p",null,"Now adding up to get ",(0,r.kt)("code",null,"(x & mask","[1]",")+ ((x >> shift) & mask","[1]",")"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  0 1 0 1 0 1 0 1\n+ 0 1 0 0 0 0 0 0\n= 1 0 0 1 0 1 0 1\n")),(0,r.kt)("p",null,"This effectively adds up each pair of bits in x as it ends up adding each odd position to the next (even) position of the original number. The masks used on next iterations are then 00110011, 00001111... and so on.")),(0,r.kt)("li",null,'What do you think would be the output of the following program and why? (If you are about to say "f is 1.0", I would say check it out again)',(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\n\nint main()\n{\n    float f=0.0f;\n    int i;\n\n    for(i=0;i<10;i++)\n        f = f + 0.1f;\n\n    if(f == 1.0f)\n        printf("f is 1.0 \\n"\n    else\n        printf("f is NOT 1.0\\n");\n\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," Output: f is NOT 1.0 Floats can't represent value 0.1 exactly because it has an infinite binary expansion the same way 1/3 has an infinite decimal expansion. 0.1 in binary is 0.000110011001100110011001100... When truncated, the decimal value used is approximately 0.100000001490116119. So after the for loop f has a value near but not exactly 1.0. The number must be compared using a narrow interval close to 1.0. A function used to compare floats is:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#define EPSILON 0.00001f\ninline int floatsEqual(float f1, float f2)\n{\n    return fabs(f1 - f2) < EPSILON; // or fabsf\n}\n")),(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://stackoverflow.com/questions/9577179/c-floating-point-precision"},"stackoverflow.com/questions/9577179/c-floating-point-precision"))),(0,r.kt)("li",null,"I thought the following C program was perfectly valid (after reading about the comma operator in C). But there is a mistake in the following program, can you identify it?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\n\nint main()\n{\n    int a = 1,2;\n    printf("a : %d\\n",a);\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," The mistake is on the line ",(0,r.kt)("code",null,"int a = 1,2;"),'. Comma in C may act as an operator or as a separator deppending on context. Comma acts as a separator when used with function calls and definitions, function like macros, variable declarations, enum declarations, and similar constructs. So here the comma is a separator, not an operator because the variable "a" is being declared. C expects another variable name after the comma: ',(0,r.kt)("code",null,"int a = 1, b = 2;"),". The line ",(0,r.kt)("code",null,"a = 1, 2;")," is also valid.",(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://www.geeksforgeeks.org/comna-in-c-and-c/"},(0,r.kt)("a",{parentName:"p",href:"http://www.geeksforgeeks.org/comna-in-c-and-c/"},"www.geeksforgeeks.org/comna-in-c-and-c/")))),(0,r.kt)("li",null,"What would be the output of the following C program? (Is it a valid C program?)",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nint main()\n{\n    int i=43;\n    printf("%d\\n",printf("%d",printf("%d",i)));\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," It is a valid C program. Its output is 4321. It's valid because printf's return type is integer. This allows nesting printfs that way. The innermost printf prints 43 and returns the number of printed characters: 2. This is printed by the second printf which returns 1, printed by the outermost printf."),(0,r.kt)("li",null,"Consider the following:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void duff(register char *to, register char *from, register int count)\n{\n    register int n=(count+7)/8;\n    switch(count%8){\n        case 0: do{ *to++ = *from++;\n        case 7:  *to++ = *from++;\n        case 6: *to++ = *from++;\n        case 5: *to++ = *from++;\n        case 4: *to++ = *from++;\n        case 3: *to++ = *from++;\n        case 2: *to++ = *from++;\n        case 1: *to++ = *from++;\n        }while( --n >0);\n    }\n}\n")),(0,r.kt)("p",null,"Is the above valid C code? If so, what is it trying to acheive and why would anyone do something like the above? "),(0,r.kt)("strong",null,"A:"),' It is valid C code, known as the Duff\'s Device. It is a memory-to-memory copy speed optimized alogorithm that copies "count" bits beggining at adress "from" into adress "to". It\'s an example of loop unrolling or unwinding, which tries to reduce the frequency of branches and loop maintenance instructions at the expense of making the code longer. An unoptimized but simpler code would be:',(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"do { \n    *to++ = *from++;\n} while(--count > 0);\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{href:"http://en.wikipedia.org/wiki/Duff%27s_device",title:"Duff's Device Wikipedia article"},"Duff's Device Wikipedia article")," for more information on why C allows to write a do-while loop inside a switch statement.")),(0,r.kt)("li",null,"Here is yet another implementation of CountBits. Verify whether it is correct (how do you that???). If so, find out the logic used.",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int CountBits(unsigned int x)\n{\n    int count=0;\n    while(x)\n    {\n        count++;\n        x = x&(x-1);\n    }\n    return count;\n}\n")),(0,r.kt)("strong",null,"A:")," The code is correct. It counts the numbers of bits set in x. The while loop iterates once for each 1 bit of the original x because the line ",(0,r.kt)("code",null,"x = x&(x-1);")," reduces the number of bits by one each time. When doing logical and of x and x-1 the rightmost 1 bit is always changed to 0, for example:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  10011010\n& 10011001\n= 10011000\n")),(0,r.kt)("p",null,"This is repeated until x is zero.")),(0,r.kt)("li",null,"Are the following two function prototypes same?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int foobar(void);\nint foobar();\n")),(0,r.kt)("p",null,"The following programs should be of some help in finding the answer: (Compile and run both the programs and see what happens)\nProgram 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nvoid foobar1(void)\n{\n    printf("In foobar1\\n");\n}\n\nvoid foobar2()\n{\n    printf("In foobar2\\n");\n}\n\nint main()\n{\n    char ch = \'a\';\n    foobar1();\n    foobar2(33, ch);\n    return 0;\n}\n')),(0,r.kt)("p",null,"Program 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nvoid foobar1(void)\n{\n    printf("In foobar1\\n");\n}\n\nvoid foobar2()\n{\n    printf("In foobar2\\n");\n}\n\nint main()\n{\n    char ch = \'a\';\n    foobar1(33, ch);\n    foobar2();\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," The function prototypes are different. When using void the function cannot receive parameters. Passing a parameter results in a \"too many arguments to function 'foobar1'\" compiling error (program 2). When using ",(0,r.kt)("code",null,"int foobar()")," prototype parameters may be passed to the function, but will just be ignored. Then program 1 is valid."),(0,r.kt)("li",null,"What's the output of the following program and why?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nint main()\n{\n    float a = 12.5;\n    printf("%d\\n", a);\n    printf("%d\\n", *(int *)&a);\n    return 0;\n}\n'))),(0,r.kt)("strong",null,"A:"),' Output: 0 1095237632 The first printf takes a float and prints it as integer. This causes print f to print "0". The second printf takes the address of a float, casts it to an integer pointer and then dereferences that as an integer. There are problems here as an integer pointer may not have the same size of a float pointer. The representations of integers and floats are also different. The behaviour may be differente depending on the compiler, but in most cases the second printf will print a big strange number.',(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://stackoverflow.com/questions/6574134/unexpected-output-printing-a-float-cast-as-an-int"},"stackoverflow.com/questions/6574134/unexpected-output-printing-a-float-cast-as-an-int")),(0,r.kt)("li",null,"The following is a small C program split across files. What do you expect the output to be, when both of them compiled together and run? File1.c",(0,r.kt)("pre",null,"int arr[80];"),(0,r.kt)("p",null,"File2.c "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"extern int *arr;\nint main()\n{\n    arr[1] = 100;\n    return 0;\n}\n")),(0,r.kt)("strong",null,"A:")," Pointer and arrays are not the same. Declaring with ",(0,r.kt)("code",null,"extern int *arr"),' tells C to use the bytes at location "arr" as if they point to something. However an array was defined there with ',(0,r.kt)("code",null,"int arr[80];"),' and array data is stored there, not a pointer. The result is that the first bytes of the array ("garbage") are dereferenced as if they were a pointer producing a segfault.',(0,r.kt)("p",null,"The solution is to make both the declaration and the definition the same with, for example ",(0,r.kt)("code",null,"extern int arr[]")," . This way C knows it is an array.")),(0,r.kt)("li",null,"Explain the output of the following C program (No, the output is not 20).",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include<stdio.h>\nint main()\n{\n    int a=1;\n    switch(a)\n    {   \n        int b=20;\n        case 1: printf("b is %d\\n",b);\n            break;\n        default:printf("b is %d\\n",b);\n            break;\n    }\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:"),' Depending on the compiler there could be a warning message ("unreachable code at beginning of switch statement") or no messages at all. The output is a random integer (garbage). The line ',(0,r.kt)("code",null,"int b=20;"),' is never executed because the switch jumps to a case (or default if there are no cases). b is therefore not initialized. Move the line right above the switch statement to get 20 as output. There is no "b not declared error" because of the inner workings of the compiler. When it gets to ',(0,r.kt)("code",null,"int b")," it sets up a variable b before assigning a value to it. The line isn't completely ignored: b is declared but not initialized.",(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://stackoverflow.com/questions/1683417/variable-declared-and-initialized-in-a-switch-statement"},"stackoverflow.com/questions/1683417/variable-declared-and-initialized-in-a-switch-statement"))),(0,r.kt)("li",null,"What is the output of the following program? (Again, it is not 40, (if the size of integer is 4)).",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#define SIZE 10\nvoid size(int arr[SIZE])\n{\n    printf("size of array is:%d\\n",sizeof(arr));\n}\n\nint main()\n{\n    int arr[SIZE];\n    size(arr);\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:"),' The output is "size of array is:4". arr is passed to the function by reference. A pointer, which takes up 4 bytes is sent to the function so in its context sizeof(arr) is 4. Moving the printf line to main() outputs the expected value of 40.'),(0,r.kt)("li",null,"The following is a simple c program, in which there is a function called Error to display errors. Can you see a potential problem with the way Error is defined?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdlib.h>\n#include <stdio.h>\nvoid Error(char* s)\n{\n    printf(s);\n    return;\n}\n\nint main()\n{\n    int *p;\n    p = malloc(sizeof(int));\n    if(p == NULL)\n    {\n        Error("Could not allocate the memory\\n");\n        Error("Quitting....\\n");\n        exit(1);\n    }\n    else\n    {\n        /*some stuff to use p*/\n    }\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," When compiling a warning is generated because ",(0,r.kt)("code",null,"printf(s)")," expects a string literal as its first argument, not a char*. Changing this line to ",(0,r.kt)("code",null,'printf("%s", s);')," does the job as it passes a string literal as first argument. The following arguments may be strings if the correct modifier is used."),(0,r.kt)("li",null,"What is the differnce between the following function calls to scanf? (Please notice the space carefully in the second call. Try removing it and observe the behaviour of the program)",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nint main()\n{\n    char c;\n    scanf("%c",&c);\n    printf("%c\\n",c);\n\n    scanf(" %c",&c);\n    printf("%c\\n",c);\n\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:"),' The first scanf scans just for a character. If there is no space before %c, when Enter is pressed the first scanf captures the character, but the newline character \\n is kept and captured by the second scanf. This is normally undesired and is fixed by adding the space. Keep in mind that newlines, spaces and tabs are characters. The space makes the second scanf scan for one or more whitespace characters followed by any character. Because the newline is whitespace character, the space "eats" it and the next character is captured as expected.'),(0,r.kt)("li",null,"What is the potential problem with the following C program?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nint main()\n{\n    char str[80];\n    printf("Enter the string:");\n    scanf("%s",str);\n    printf("You entered:%s\\n",str);\n\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," The problem is that %s scans for any number of non-whitespace characters, stopping at the first whitespace character found. This means that just the first word will be captured. To capture a complete line use ",(0,r.kt)("code",null,'scanf("%[^\\n]",str);')," which captureseverything until a newline character is entered."),(0,r.kt)("li",null,"What is the output of the following program?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nint main()\n{\n    int i;\n    i = 10;\n    printf("i : %d\\n",i);\n    printf("sizeof(i++) is: %d\\n",sizeof(i++));\n    printf("i : %d\\n",i);\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," Output:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"i : 10\nsizeof(i++) is: 4\ni : 10\n")),(0,r.kt)("p",null,'The expression in a sizeof is not evaluated because sizeof is not a function, but a compile-time operator. Only its operand\'s type is used to determine size. The sizeof(i++) expresion is then replaced by a constant, so there is no "++" at run-time.'),(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://stackoverflow.com/questions/1581839/whats-the-mechanism-of-sizeof-in-c-c"},"stackoverflow.com/questions/1581839/whats-the-mechanism-of-sizeof-in-c-c"))),(0,r.kt)("li",null,"Why does the following program give a warning? (Please remember that sending a normal pointer to a function requiring const pointer does not give any warning)",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#include <stdio.h>\nvoid foo(const char **p) { }\nint main(int argc, char **argv)\n{\n    foo(argv);\n    return 0;\n}\n")),(0,r.kt)("strong",null,"A:")," A char** is being passed to a function that requires a const char**. A pointer to a constant is one through which one cannot change the value of variable it points. These pointers can change the address they point to but cannot change the value kept at those addresses. This is known as const-correctness. There is no cast from char** to const char** even when there is between char* and const char* because it would not be const-correct. If this assignment was allowed the following code would be valid:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"char const        c = 'a';\nchar*             p = 0;\nchar const**      pp = &p; // not allowed in C\n\n*pp = &c; // p now points to c.\n*p = 'b'; // changing a const value!\n")),(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://stackoverflow.com/questions/7016098/implicit-cast-from-char-to-const-char"},"stackoverflow.com/questions/7016098/implicit-cast-from-char-to-const-char"))),(0,r.kt)("li",null,"What is the output of the following program?",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <stdio.h>\nint main()\n{\n    int i;\n    i = 1,2,3;\n    printf("i:%d\\n",i);\n    return 0;\n}\n')),(0,r.kt)("strong",null,"A:")," Output: i:1 Here comma acts as a separator. It separates expressions and returns the value of the expression to its right. ",(0,r.kt)("code",null,"i = 1,2,3;")," is equivalent to ",(0,r.kt)("code",null,"(i=1),2,3;"),". The whole line evaluates to the last expression: 3, but it is not being stored. ",(0,r.kt)("code",null,"i = (1,2,3);")," stores 3 into i.",(0,r.kt)("p",null,"Source: ",(0,r.kt)("a",{href:"http://en.wikipedia.org/wiki/Comma_operator"},"en.wikipedia.org/wiki/Comma_operator"))),(0,r.kt)("li",null,"The following is a piece of code which implements the reverse Polish Calculator. There are serious bugs in the code. Find them!!! Assume that the function getop returns the appropriate return values for operands, opcodes, EOF etc...",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 80\n#define NUMBER '0'\n\nint getop(char[]);\nvoid push(double);\ndouble pop(void);\nint main()\n{\n    int type;\n    char s[MAX];\n\n    while((type = getop(s)) != EOF)\n    {\n        switch(type)\n        {\n            case NUMBER:\n                push(atof(s));\n                break;\n            case '+':\n                push(pop() + pop());\n                break;\n            case '*':\n                push(pop() * pop());\n                break;\n            case '-':\n                push(pop() - pop());\n                break;\n            case '/':\n                push(pop() / pop());\n                break;\n            /*   ... \n             *   ...    \n             *   ... \n             */\n        }\n    }\n}\n")),(0,r.kt)("strong",null,"A:")," Reverse Polish notation is a mathematical notation in which every operator follows all of its operands. Here the operands are stacked and accessed when an operator is processed. In case '-' and case '/' the expected output is the first operand minus/divided by the second one. Supposing it's a LIFO stack the order is incorrect. The second operand (last stacked) should be substracted from the first one:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"case '-':\n    op2 = pop();\n    push(pop() - op2);\n    break;\ncase '/':\n    op2 = pop();\n    if (op2 != 0.0)\n        push(pop() / op2);\n    else\n        printf(\"error: zero divisor\\n\");\n    break;\n")),(0,r.kt)("p",null,"This code also checks if the second operand is zero, to avoid trying to divide by zero."))),(0,r.kt)("p",null,"The C puzzles questions, by ",(0,r.kt)("a",{rel:"cc:attributionURL",property:"cc:attributionName",href:"http://www.gowrikumar.com"},"CH Gowri Kumar")," are licensed under a ",(0,r.kt)("a",{rel:"license",href:"http://creativecommons.org/licenses/by-sa/3.0/"},"Creative Commons Attribution-ShareAlike 3.0 Unported License"),"."))}c.isMDXComponent=!0}}]);