<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://josedvq.github.io/blog</id>
    <title>Jose Vargas-Quiros Blog</title>
    <updated>2013-09-09T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://josedvq.github.io/blog"/>
    <subtitle>Jose Vargas-Quiros Blog</subtitle>
    <icon>https://josedvq.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Responsive CSS triangles]]></title>
        <id>responsive-css-triangles</id>
        <link href="https://josedvq.github.io/blog/responsive-css-triangles"/>
        <updated>2013-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Fixed width CSS triangles can be created easily by specifying two transparent borders and a colored border to a zero width and zero height element. Creating variable width triangles for responsive designs is not straightforward because CSS accepts border widths in pixels only. I came accross this issue recently while working on making my color picker plugin responsive.]]></summary>
        <content type="html"><![CDATA[<p>Fixed width CSS triangles can be created easily by specifying two transparent borders and a colored border to a zero width and zero height element. Creating variable width triangles for responsive designs is not straightforward because CSS accepts border widths in pixels only. I came accross this issue recently while working on making my color picker plugin responsive.</p><p>I came up with a simple solution that uses <strong>two divs or one div and a pseudo-element</strong> to create responsive CSS triangles. Both consist of a large fixed width triangle that is covered/uncovered according to width, effectively faking responsiveness. Partially covering/uncovering the triangle makes it keep its proportions. </p><p>Now, to the code. The following are up, down, right and left pointing CSS triangles. The code is presented for both the one and two div versions. The logic used is exactly the same for both. Using two divs makes these pure CSS triangles compatible with IE7, which does not support pseudo-elements. I set up a JSFiddle for playing around with the two-div triangles: <a href="http://jsfiddle.net/josedvq/xEGM4/" target="_blank" rel="noopener noreferrer">jsfiddle.net/josedvq/xEGM4</a> and one div triangles: <a href="http://jsfiddle.net/josedvq/3HG6d/" target="_blank" rel="noopener noreferrer">jsfiddle.net/josedvq/3HG6d</a>.</p><p>Note: For the triangles to work properly box-sizing should be set to content-box (the CSS default). Add this rule to the triangle's class if necessary.</p><h2>Up-pointing CSS triangles</h2><small>The following triangle is set to take 25% of the width of its container.</small><script async="" src="https://jsfiddle.net/josedvq/kjfgpm8u/2/embed/html,css,result/dark/"></script><p>This code creates a responsive triangle with base-height ratio of 2, and width 100% (of its parent). To modify this code its necessary to understand how to set the triangles proportions. In short:</p><p><code>(padding-left + width)/padding-bottom = (border-left + border-right)/border-bottom = base/height</code></p><p><code>margin-left = -border-left = -border-right</code></p><p><code>width = padding-left</code></p><strong>Where base/height is the base to height ratio of the desired CSS triangle. border-left + border-right is the maximum lenght of the base and border-bottom the maximum height of the responsive triangle.</strong> Your responsive triangle won't get any bigger than the inner fixed width triangle formed by this borders. Be sure to set the px widths to values large enough and with the proportions you expect the triangle to have. This internal triangle is uncovered as width increases, so these px values determine its proportions.<p>The outer div must uncover the fixed width triangle keeping its proportions. In the code given the total width of the triangle is width(50%) + padding-left(50%) = 100% of its parent's width. Padding and width may be set to any other value, but should be the same for both (use 25% to create a 50% total width triangle). The total height of the outer div is height(0) + padding-bottom(50%) = 50%. Here we are taking advantage of percentages in padding being calculated against parent's width. The porportions are kept: total width/total height = 2 in the example.</p><p>For example, for an equilateral triangle base = 1.1547*height, so (border-left + border-right)/border-bottom should be base/height = 1.1547. To create a 200px maximum width equilateral triangle set border-left = border-right = 100px and border-bottom = 200/1.1547 = 173px (rounded). Then we have that (padding-left + width)/padding-bottom should also be 1.1547. Say yow want it to take 20% of its parent width. Set padding-left = 10%, width = 10% and padding-bottom = 20%/1.1547 = 18.1865%.</p><h2>Down-pointing CSS triangles</h2><small>The following triangle is set to take 25% of the width of its container.</small><script async="" src="//jsfiddle.net/josedvq/oxqkv4wz/17/embed/html,css,result/dark/"></script><p>Change the triangle proportions respecting:</p><p><code>(padding-left + width)/padding-top = (border-left + border-right)/border-top = base/height</code></p><p><code>margin-left = -border-left = -border-right</code></p><p><code>margin-top = -border-top</code></p><p><code>width = padding-left</code></p><p>Where base/height is the base-height ratio of the desired responsive triangle. border-left and border-right set the maximum length of the base and border-top sets the maximum height. Set this fixed width triangle to be larger than the largest triangle your layout will use.  Just be sure to use the porportions you want your responsive CSS triangle to have. Then set the div's padding-left, padding-top and width according to these proportions (change just padding-top for total width = 100%).
For the <code>:after</code> pseudo-element set <code>margin-left = - border-left</code> and <code>margin-top = - border-top</code>.</p><h2>Right-pointing CSS triangles</h2><small>The following triangle is set to take 25% of the width of its container.</small><script async="" src="//jsfiddle.net/josedvq/3Ly2u7gk/3/embed/html,css,result/dark/"></script><p>Change the triangle proportions respecting:</p><p><code>(padding-top + padding-bottom)/padding-left = (border-top + border-bottom)/border-left = base/height</code></p><p><code>margin-left = -border-left</code></p><p><code>margin-top = -border-top = -border-bottom</code></p><p><code>padding-top = padding-bottom</code></p><h2>Left-pointing CSS triangles</h2><small>The following triangle is set to take 25% of the width of its container.</small><script async="" src="//jsfiddle.net/josedvq/9ar5pLmv/2/embed/html,css,result/dark/"></script><p>Change the triangle proportions respecting:</p><p><code>(padding-top + padding-bottom)/width = (border-top + border-bottom)/border-right = base/height</code></p><p><code>margin-top = -border-top = -border-bottom</code></p><p><code>padding-top = padding-bottom</code></p><h2>Up-right, up-left, down-right, down-left pointing triangles</h2><p>For the up-right, down-right, down-left and up-left pointing CSS triangles I'll present the one-div CSS code.</p><small>The following triangles are set to take 25% of the width of their container.</small><script async="" src="//jsfiddle.net/josedvq/mhsu4zec/2/embed/html,css,result/dark/"></script><p>That's it for now. I'll be writing other articles on CSS shapes soon. If you have any trouble on using these responsive CSS triangles please leave a comment below.</p>]]></content>
        <author>
            <name>Jose Vargas</name>
            <uri>https://github.com/josedvq</uri>
        </author>
        <category label="css" term="css"/>
        <category label="triangles" term="triangles"/>
        <category label="responsive" term="responsive"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[C Puzzles Part 1]]></title>
        <id>c-puzzles</id>
        <link href="https://josedvq.github.io/blog/c-puzzles"/>
        <updated>2013-08-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The C Puzzles by Gowri Kumar are fifty C language programs meant to be compiled, run and explained. It's a great resource for those who are learning C. You'll learn the most if you use this post to compare with your own answers.]]></summary>
        <content type="html"><![CDATA[<p>The <a href="http://www.gowrikumar.com/c/" target="_blank" rel="noopener noreferrer" title="Go to Gowri Kumar's website">C Puzzles</a> by Gowri Kumar are fifty C language programs meant to be compiled, run and explained. It's a great resource for those who are learning C. You'll learn the most if you use this post to compare with your own answers.</p><p>I took the time to understand and answer the first 25 problems. I'm not a C programmer (just know the basics) but did my best to explain each program both from my knowledge and googling for answers. Don't believe these are the correct answers as they may in fact be wrong. Most of the C puzzles answers may be found on different forums and Q&amp;A sites but were not gathered on a single place before. Hope it helps. Please leave feedback and let me know any errors you find using the comments at the end of the page.</p><ol><li>The expected output of the following C program is to print the elements in the array. But when actually run, it doesn't do so.<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int array[] = {23,34,12,17,204,99,16};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main(){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    for(d=-1;d &lt;= (TOTAL_ELEMENTS-2);d++)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printf("%d\n",array[d+1]);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Find out what's going wrong.</p><strong>A:</strong> The for loop is not being executed. <code>TOTAL_ELEMENTS</code> is of type size_t which is unsigned. <code>d</code> is of type signed int. When an operator has a signed and an unsigned argument, and the unsigned argument is of greater or equal size to the signed argument, then the signed argument is converted to unsigned. So -1 is converted to 2^32 - 1 which of course is larger than <code>TOTAL_ELEMENTS - 2</code>. The comparisson is false. Forcing conversion to signed int with<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">for(d=-1;d &lt;= (signed int)(TOTAL_ELEMENTS-2);d++)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>makes it work as expected.</p></li><li>I thought the following program was a perfect C program. But on compiling, I found a silly mistake. Can you find it out (without compiling the program :-) ?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include&lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void OS_Solaris_print()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("Solaris - Sun Microsystems\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void OS_Windows_print()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("Windows - Microsoft\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void OS_HP-UX_print()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("HP-UX - Hewlett Packard\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int num;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("Enter the number (1-3):\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    scanf("%d",&amp;num);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    switch(num)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 1:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            OS_Solaris_print();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 2:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            OS_Windows_print();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 3:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            OS_HP-UX_print();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        default:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            printf("Hmm! only 1-3 :-)\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> There's a dash in the function name <code>void OS_HP-UX_print()</code>. C does not accept dashes in function names. It must be deleted or changed by an underscore for the program to work.</li><li>What's the expected output for the following program and why?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">enum {false,true};</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int i=1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    do</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printf("%d\n",i);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        i++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if(i &lt; 15)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            continue;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }while(false);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Output: 1 The continue statement passes control to the next iteration of the nearest enclosing do, for, or while statement in which it appears. Within a do or a while statement, the next iteration starts by reevaluating the expression of the do or while statement. In this case, the expression is false so there are no more iterations.</li><li>The following program doesn't "seem" to print "hello-out". (Try executing it)<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;unistd.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    while(1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        fprintf(stdout,"hello-out");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        fprintf(stderr,"hello-err");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        sleep(1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> What is sent to stdout is kept in a buffer and is printed until a newline is sent. If the program ends without sending a newline to stdout nothing is printed. What is sent to stderr is printed immediatly. That's why just "hello-err" is printed. Change "hello-out" for "hello-out\n" to print it.</li><li>Consider the following:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define f(a,b) a##b</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define g(a)   #a</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define h(a) g(a)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%s\n",h(f(1,2)));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%s\n",g(f(1,2)));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Just by looking at the program one "might" expect the output to be the same for both the printf statements. But on running the program you get it as:
12
f(1,2)</p><strong>A:</strong> The definitions at the beggining are macros, read by the C preprocesor. The transforming or "evaluating" of a macro into a sequence is known as expansion. The parameter of a function-like macro is expanded unless it is the operand # or ##. Because g's parameter is the operand #, the argument is not expanded but instead immediately stringified "f(1,2)". Because h's parameter is not the operand # nor ##, the argument f(1,2) is expanded (12), then substituted (g(12)). Then the code is rescanned and further expansion occurs ("12").<p>Source: <a href="http://stackoverflow.com/questions/4364971/and-in-macros" target="_blank" rel="noopener noreferrer">stackoverflow.com/questions/4364971/and-in-macros</a></p></li><li>Consider the following:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include&lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int a=10;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    switch(a)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case '1':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            printf("ONE\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case '2':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            printf("TWO\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        defa1ut:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            printf("NONE\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>If you expect the output of the above program to be NONE, I would request you to check it out!!</p><strong>A:</strong> The program doesn't print anything because the switch has no default case. It says "defau1t", not "default" so it is simply ignored. It is not a syntax error as it is treated as a normal <a href="http://msdn.microsoft.com/en-us/library/2c002fdz.aspx" target="_blank" rel="noopener noreferrer">C label</a>.</li><li>The following C program segfaults on IA-64, but works fine on IA-32.<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int* p;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    p = (int*)malloc(sizeof(int));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    *p = 10;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Why does it happen so?</p><strong>A:</strong> It happens because on IA-64 a pointer takes up 64 bits, more than an integer (32 bits). Without the header file stdlib.h the return type of malloc is assumed to be integer, not pointer (int is the default return type in C). The returned 64 bits are truncated to 32 and then the line <code>p = (int*)malloc(sizeof(int));</code> casts it to a 64 bit pointer. This, of course, damages the pointer causing a segfault when trying to write. Add stdlib.h to tell C to expect a pointer returned from malloc and fix the problem.</li><li>Here is a small piece of program(again just 14 lines of program) which counts the number of bits set in a number.<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Input   Output</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0   0(0000000)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">5   2(0000101)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">7   3(0000111) </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int CountBits (unsigned int x )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    static unsigned int mask[] = { 0x55555555,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        0x33333333,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        0x0F0F0F0F,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        0x00FF00FF,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        0x0000FFFF</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int i ;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int shift ; /* Number of positions to shift to right*/</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    for ( i =0, shift =1; i &lt; 5; i ++, shift *= 2)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        x = (x &amp; mask[i ])+ ( ( x &gt;&gt; shift) &amp; mask[i]);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return x;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Find out the logic used in the above program.</p><strong>A:</strong> This algorithm counts the number of ones in a number in binary. It does so by "dividing" the original number in pairs of bits and adding both bits of each pair. It keeps adding the results until there are no more groups to add. For example, for 11010101:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">| 1 + 1 | 0 + 1 | 0 + 1 | 0 + 1 |  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|  1 0  +  0 1  |  0 1  +  0 1  |  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|    0 0 1 1    +    0 0 1 0    |  </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|        0 0 0 0 0 1 0 1        |</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The code given doesn't look as intuitive because it uses masks to add the groups of bits, optimizing the number of operations. Take, for example, the first iteration. The first mask is 0x55555555 = 01010101...0101 The logical AND of this mask and x <code>(x &amp; mask<!-- -->[1]<!-- -->)</code> makes zero all odd positions of x:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">  1 1 0 1 0 1 0 1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&amp; 0 1 0 1 0 1 0 1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">= 0 1 0 1 0 1 0 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Shifting x to the right and then applying the mask to get <code>((x &gt;&gt; shift) &amp; mask<!-- -->[1]<!-- -->)</code> makes zero all even positions:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">  1 1 1 0 1 0 1 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&amp; 0 1 0 1 0 1 0 1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">= 0 1 0 0 0 0 0 0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now adding up to get <code>(x &amp; mask<!-- -->[1]<!-- -->)+ ((x &gt;&gt; shift) &amp; mask<!-- -->[1]<!-- -->)</code>:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">  0 1 0 1 0 1 0 1</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+ 0 1 0 0 0 0 0 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">= 1 0 0 1 0 1 0 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This effectively adds up each pair of bits in x as it ends up adding each odd position to the next (even) position of the original number. The masks used on next iterations are then 00110011, 00001111... and so on.</p></li><li>What do you think would be the output of the following program and why? (If you are about to say "f is 1.0", I would say check it out again)<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    float f=0.0f;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    for(i=0;i&lt;10;i++)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        f = f + 0.1f;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if(f == 1.0f)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printf("f is 1.0 \n"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printf("f is NOT 1.0\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Output: f is NOT 1.0 Floats can't represent value 0.1 exactly because it has an infinite binary expansion the same way 1/3 has an infinite decimal expansion. 0.1 in binary is 0.000110011001100110011001100... When truncated, the decimal value used is approximately 0.100000001490116119. So after the for loop f has a value near but not exactly 1.0. The number must be compared using a narrow interval close to 1.0. A function used to compare floats is:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define EPSILON 0.00001f</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">inline int floatsEqual(float f1, float f2)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return fabs(f1 - f2) &lt; EPSILON; // or fabsf</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Source: <a href="http://stackoverflow.com/questions/9577179/c-floating-point-precision" target="_blank" rel="noopener noreferrer">stackoverflow.com/questions/9577179/c-floating-point-precision</a></p></li><li>I thought the following C program was perfectly valid (after reading about the comma operator in C). But there is a mistake in the following program, can you identify it?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int a = 1,2;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("a : %d\n",a);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> The mistake is on the line <code>int a = 1,2;</code>. Comma in C may act as an operator or as a separator deppending on context. Comma acts as a separator when used with function calls and definitions, function like macros, variable declarations, enum declarations, and similar constructs. So here the comma is a separator, not an operator because the variable "a" is being declared. C expects another variable name after the comma: <code>int a = 1, b = 2;</code>. The line <code>a = 1, 2;</code> is also valid.<p>Source: <a href="http://www.geeksforgeeks.org/comna-in-c-and-c/" target="_blank" rel="noopener noreferrer"></a><a href="http://www.geeksforgeeks.org/comna-in-c-and-c/" target="_blank" rel="noopener noreferrer">www.geeksforgeeks.org/comna-in-c-and-c/</a></p></li><li>What would be the output of the following C program? (Is it a valid C program?)<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int i=43;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%d\n",printf("%d",printf("%d",i)));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> It is a valid C program. Its output is 4321. It's valid because printf's return type is integer. This allows nesting printfs that way. The innermost printf prints 43 and returns the number of printed characters: 2. This is printed by the second printf which returns 1, printed by the outermost printf.</li><li>Consider the following:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">void duff(register char *to, register char *from, register int count)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    register int n=(count+7)/8;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    switch(count%8){</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 0: do{ *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 7:  *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 6: *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 5: *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 4: *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 3: *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 2: *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 1: *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }while( --n &gt;0);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Is the above valid C code? If so, what is it trying to acheive and why would anyone do something like the above? </p><strong>A:</strong> It is valid C code, known as the Duff's Device. It is a memory-to-memory copy speed optimized alogorithm that copies "count" bits beggining at adress "from" into adress "to". It's an example of loop unrolling or unwinding, which tries to reduce the frequency of branches and loop maintenance instructions at the expense of making the code longer. An unoptimized but simpler code would be:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">do { </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    *to++ = *from++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">} while(--count &gt; 0);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>See <a href="http://en.wikipedia.org/wiki/Duff%27s_device" target="_blank" rel="noopener noreferrer" title="Duff's Device Wikipedia article">Duff's Device Wikipedia article</a> for more information on why C allows to write a do-while loop inside a switch statement.</p></li><li>Here is yet another implementation of CountBits. Verify whether it is correct (how do you that???). If so, find out the logic used.<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int CountBits(unsigned int x)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int count=0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    while(x)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        count++;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        x = x&amp;(x-1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return count;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> The code is correct. It counts the numbers of bits set in x. The while loop iterates once for each 1 bit of the original x because the line <code>x = x&amp;(x-1);</code> reduces the number of bits by one each time. When doing logical and of x and x-1 the rightmost 1 bit is always changed to 0, for example:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">  10011010</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&amp; 10011001</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">= 10011000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is repeated until x is zero.</p></li><li>Are the following two function prototypes same?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int foobar(void);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int foobar();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The following programs should be of some help in finding the answer: (Compile and run both the programs and see what happens)
Program 1:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void foobar1(void)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("In foobar1\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void foobar2()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("In foobar2\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char ch = 'a';</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    foobar1();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    foobar2(33, ch);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Program 2:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void foobar1(void)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("In foobar1\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void foobar2()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("In foobar2\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char ch = 'a';</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    foobar1(33, ch);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    foobar2();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> The function prototypes are different. When using void the function cannot receive parameters. Passing a parameter results in a "too many arguments to function 'foobar1'" compiling error (program 2). When using <code>int foobar()</code> prototype parameters may be passed to the function, but will just be ignored. Then program 1 is valid.</li><li>What's the output of the following program and why?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    float a = 12.5;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%d\n", a);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%d\n", *(int *)&amp;a);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><strong>A:</strong> Output: 0 1095237632 The first printf takes a float and prints it as integer. This causes print f to print "0". The second printf takes the address of a float, casts it to an integer pointer and then dereferences that as an integer. There are problems here as an integer pointer may not have the same size of a float pointer. The representations of integers and floats are also different. The behaviour may be differente depending on the compiler, but in most cases the second printf will print a big strange number.<p>Source: <a href="http://stackoverflow.com/questions/6574134/unexpected-output-printing-a-float-cast-as-an-int" target="_blank" rel="noopener noreferrer">stackoverflow.com/questions/6574134/unexpected-output-printing-a-float-cast-as-an-int</a></p><li>The following is a small C program split across files. What do you expect the output to be, when both of them compiled together and run? File1.c<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int arr[80];</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>File2.c </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">extern int *arr;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    arr[1] = 100;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Pointer and arrays are not the same. Declaring with <code>extern int *arr</code> tells C to use the bytes at location "arr" as if they point to something. However an array was defined there with <code>int arr[80];</code> and array data is stored there, not a pointer. The result is that the first bytes of the array ("garbage") are dereferenced as if they were a pointer producing a segfault.<p>The solution is to make both the declaration and the definition the same with, for example <code>extern int arr[]</code> . This way C knows it is an array.</p></li><li>Explain the output of the following C program (No, the output is not 20).<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include&lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int a=1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    switch(a)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {   </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        int b=20;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case 1: printf("b is %d\n",b);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        default:printf("b is %d\n",b);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Depending on the compiler there could be a warning message ("unreachable code at beginning of switch statement") or no messages at all. The output is a random integer (garbage). The line <code>int b=20;</code> is never executed because the switch jumps to a case (or default if there are no cases). b is therefore not initialized. Move the line right above the switch statement to get 20 as output. There is no "b not declared error" because of the inner workings of the compiler. When it gets to <code>int b</code> it sets up a variable b before assigning a value to it. The line isn't completely ignored: b is declared but not initialized.<p>Source: <a href="http://stackoverflow.com/questions/1683417/variable-declared-and-initialized-in-a-switch-statement" target="_blank" rel="noopener noreferrer">stackoverflow.com/questions/1683417/variable-declared-and-initialized-in-a-switch-statement</a></p></li><li>What is the output of the following program? (Again, it is not 40, (if the size of integer is 4)).<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define SIZE 10</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void size(int arr[SIZE])</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("size of array is:%d\n",sizeof(arr));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int arr[SIZE];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    size(arr);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> The output is "size of array is:4". arr is passed to the function by reference. A pointer, which takes up 4 bytes is sent to the function so in its context sizeof(arr) is 4. Moving the printf line to main() outputs the expected value of 40.</li><li>The following is a simple c program, in which there is a function called Error to display errors. Can you see a potential problem with the way Error is defined?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void Error(char* s)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(s);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int *p;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    p = malloc(sizeof(int));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if(p == NULL)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Error("Could not allocate the memory\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        Error("Quitting....\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        exit(1);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        /*some stuff to use p*/</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> When compiling a warning is generated because <code>printf(s)</code> expects a string literal as its first argument, not a char*. Changing this line to <code>printf("%s", s);</code> does the job as it passes a string literal as first argument. The following arguments may be strings if the correct modifier is used.</li><li>What is the differnce between the following function calls to scanf? (Please notice the space carefully in the second call. Try removing it and observe the behaviour of the program)<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char c;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    scanf("%c",&amp;c);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%c\n",c);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    scanf(" %c",&amp;c);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("%c\n",c);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> The first scanf scans just for a character. If there is no space before %c, when Enter is pressed the first scanf captures the character, but the newline character \n is kept and captured by the second scanf. This is normally undesired and is fixed by adding the space. Keep in mind that newlines, spaces and tabs are characters. The space makes the second scanf scan for one or more whitespace characters followed by any character. Because the newline is whitespace character, the space "eats" it and the next character is captured as expected.</li><li>What is the potential problem with the following C program?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char str[80];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("Enter the string:");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    scanf("%s",str);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("You entered:%s\n",str);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> The problem is that %s scans for any number of non-whitespace characters, stopping at the first whitespace character found. This means that just the first word will be captured. To capture a complete line use <code>scanf("%[^\n]",str);</code> which captureseverything until a newline character is entered.</li><li>What is the output of the following program?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    i = 10;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("i : %d\n",i);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("sizeof(i++) is: %d\n",sizeof(i++));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("i : %d\n",i);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Output:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">i : 10</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">sizeof(i++) is: 4</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">i : 10</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The expression in a sizeof is not evaluated because sizeof is not a function, but a compile-time operator. Only its operand's type is used to determine size. The sizeof(i++) expresion is then replaced by a constant, so there is no "++" at run-time.</p><p>Source: <a href="http://stackoverflow.com/questions/1581839/whats-the-mechanism-of-sizeof-in-c-c" target="_blank" rel="noopener noreferrer">stackoverflow.com/questions/1581839/whats-the-mechanism-of-sizeof-in-c-c</a></p></li><li>Why does the following program give a warning? (Please remember that sending a normal pointer to a function requiring const pointer does not give any warning)<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void foo(const char **p) { }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main(int argc, char **argv)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    foo(argv);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> A char** is being passed to a function that requires a const char**. A pointer to a constant is one through which one cannot change the value of variable it points. These pointers can change the address they point to but cannot change the value kept at those addresses. This is known as const-correctness. There is no cast from char** to const char** even when there is between char* and const char* because it would not be const-correct. If this assignment was allowed the following code would be valid:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">char const        c = 'a';</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">char*             p = 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">char const**      pp = &amp;p; // not allowed in C</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">*pp = &amp;c; // p now points to c.</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">*p = 'b'; // changing a const value!</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Source: <a href="http://stackoverflow.com/questions/7016098/implicit-cast-from-char-to-const-char" target="_blank" rel="noopener noreferrer">stackoverflow.com/questions/7016098/implicit-cast-from-char-to-const-char</a></p></li><li>What is the output of the following program?<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    i = 1,2,3;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf("i:%d\n",i);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Output: i:1 Here comma acts as a separator. It separates expressions and returns the value of the expression to its right. <code>i = 1,2,3;</code> is equivalent to <code>(i=1),2,3;</code>. The whole line evaluates to the last expression: 3, but it is not being stored. <code>i = (1,2,3);</code> stores 3 into i.<p>Source: <a href="http://en.wikipedia.org/wiki/Comma_operator" target="_blank" rel="noopener noreferrer">en.wikipedia.org/wiki/Comma_operator</a></p></li><li>The following is a piece of code which implements the reverse Polish Calculator. There are serious bugs in the code. Find them!!! Assume that the function getop returns the appropriate return values for operands, opcodes, EOF etc...<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define MAX 80</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#define NUMBER '0'</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int getop(char[]);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void push(double);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">double pop(void);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int type;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char s[MAX];</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    while((type = getop(s)) != EOF)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        switch(type)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            case NUMBER:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                push(atof(s));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            case '+':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                push(pop() + pop());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            case '*':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                push(pop() * pop());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            case '-':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                push(pop() - pop());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            case '/':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                push(pop() / pop());</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            /*   ... </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             *   ...    </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             *   ... </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><strong>A:</strong> Reverse Polish notation is a mathematical notation in which every operator follows all of its operands. Here the operands are stacked and accessed when an operator is processed. In case '-' and case '/' the expected output is the first operand minus/divided by the second one. Supposing it's a LIFO stack the order is incorrect. The second operand (last stacked) should be substracted from the first one:<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">case '-':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    op2 = pop();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    push(pop() - op2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">case '/':</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    op2 = pop();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (op2 != 0.0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        push(pop() / op2);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        printf("error: zero divisor\n");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    break;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This code also checks if the second operand is zero, to avoid trying to divide by zero.</p></li></ol><p>The C puzzles questions, by <a href="http://www.gowrikumar.com" target="_blank" rel="cc:attributionURL" property="cc:attributionName">CH Gowri Kumar</a> are licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="license">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</p>]]></content>
        <author>
            <name>Jose Vargas</name>
            <uri>https://github.com/josedvq</uri>
        </author>
        <category label="c" term="c"/>
        <category label="puzzles" term="puzzles"/>
        <category label="programming puzzles" term="programming puzzles"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Getting started with Icarus Verilog on Windows]]></title>
        <id>getting-started-icarus-verilog</id>
        <link href="https://josedvq.github.io/blog/getting-started-icarus-verilog"/>
        <updated>2013-08-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Icarus Verilog is a Verilog standard IEEE-1364 compiler that targets Linux but works almost as well on Windows. It's lightweight, free software and includes a virtual machine that simulates the design. This tutorial goes through the process of downloading, installing and using Icarus Verilog to write a simple program, compile it, simulate it and view the simulation results on a timing diagram. It assumes no previous knowledge on Verilog, but prior programming experience is recommended.]]></summary>
        <content type="html"><![CDATA[<a href="http://iverilog.icarus.com/" target="_blank" rel="noopener noreferrer" title="Icarus Verilog official website">Icarus Verilog</a> is a <a href="http://en.wikipedia.org/wiki/Verilog" target="_blank" rel="noopener noreferrer" title="Article on Verilog Hardware Description Language">Verilog standard IEEE-1364</a> compiler that targets Linux but works almost as well on Windows. It's lightweight, free software and includes a virtual machine that simulates the design. This tutorial goes through the process of downloading, installing and using Icarus Verilog to write a simple program, compile it, simulate it and view the simulation results on a timing diagram. It assumes no previous knowledge on Verilog, but prior programming experience is recommended.<h2>Installing Icarus Verilog</h2><p>Download Icarus Verilog latest stable release for Windows from: <a href="http://bleyer.org/icarus/" target="_blank" rel="noopener noreferrer" title="Get Icarus Verilog for Windows">bleyer.org/icarus</a></p><p>Installing Icarus Verilog is as easy as installing any other Windows program. Just hit next, but be sure to select GTK Wave (full installation) and "Add Executables to Windows Path" option. You should be able to use it from a Command Prompt by now. On Windows Vista/7/8 press Windows key and type cmd to open a command prompt. Just type "iverilog" and you should get a message saying "iverilog: no source files" and some instructions. Type "gtkwave" and the GTKWave GUI should open. This program is used to view the simulation results graphically on a timing diagram.</p><p>If these commands are not recognized but the installation was successful chances are the executables were not added to Windows Path. See <a href="http://www.computerhope.com/issues/ch000549.htm" target="_blank" rel="noopener noreferrer" title="How to set the Path on Windows">How to set the Path on Windows</a> to add "C:\iverilog\bin" to Path manually.</p><h2>Writing a simple program</h2><p>Now you are ready to write your first Verilog program. For this tutorial we'll write a D type flip-flop description, that is, a Verilog module that works like a D flip-flop. At the same time you'll learn some of the basic Verilog concepts by example.&nbsp; You'll also write a tester module to reproduce the following D flip-flop timing diagram:</p><img loading="lazy" class="aligncenter size-full wp-image-139" alt="D type flip-flop timing diagram" src="http://localhost:8888/cid/wp-content/uploads/2013/08/fftiming.gif" width="475" height="257"><p>Verilog programs are separated in modules, which are functional blocks that have inputs, outputs and internal logic. You can think of them like the blocks on a circuit's block diagram, but in this case they work. There are two types of Verilog modules: behavioral modules and structural modules. Both may have the same behaviour but are different in the way they are written as you'll see throughout the example.</p><p>For the flip-flop program three modules are used: the flip-flop module, tester module and testbench module. The last two are modules you'll need on almost every design in order to test your circuit.</p><h3>Flip-flop module</h3><p>Represents a simple D type flip-flop. Receives a clock signal and D signal as inputs and outputs Q and QN signals. The outputs may change on the positive clock edge. The code for this module is:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">module dff(d,clk,q,qn);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    input d,clk;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    output q,qn;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    reg q,qn;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Initialize flip-flop outputs</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    initial begin q=0; qn=1; end</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Change output on positive clock edge</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    always @(posedge clk) </span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        q &amp;lt;= d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        qn &amp;lt;= !d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>From this code, you can see the basic structure of every Verilog module. It starts with a declaration: <code>module dff(d,clk,q,qn);</code> and ends with <code>endmodule</code>. The declaration states the module's name and both its inputs and outputs. In the module we must declare which variables are inputs and which are outputs, using "input" and "output".</p><p>Variables in Verilog are wires or regs. A wire, like a real wire, has no memory. Thus Verilog wire variables do not retain their values by themselves. The reg keyword gives variables the ability to hold their values after they are assigned, until their value is changed, of course. We want this behaviour for the flip-flop's outputs so q and qn are defined as regs. If we use a wire the output is never seen by other blocks. It loses its value immediatly after any assignment. There is no need to define variables as wires, because they are all wires by default.</p><p>The way the inner logic of the module is written deppends on wether it is behavioral or structural. The flip-flop module is an example of behavioral code. That is, you describe the behavior the module should have. To do it, use initial and always blocks. The code within an initial block is executed once, when the flip-flop is created. In the example it's used to define q=0 and qn=1 initially. By default in Verilog the variables are undefined (represented by an "x"), not zero, not one. If we did'nt use this initial block q and qn would be left undefined until they are assigned for the first time.</p><p>The code within an always block is executed when a condition is met. In this case, when the clock has a positive edge, q and qn are reassigned. This describes completely the flip-flop's logic. As you can see, it is simple. When the condition is not met, Verilog keeps the outputs' values.</p><p>As a rule of thumb, when writing a behavioral module, define outputs as wires.</p><p>Verilog has control structures like while, if-else, case, for and repeat (similar to for) like most programming languages. These assist you on writting your behavioral code. For example, replacing the flip-flop module's always block by:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if(clk == 1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        q &amp;lt;= d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        qn &amp;lt;= !d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>produces exactly the same behaviour. Some things changed. Now the always condition is <code>always @(clk) </code> instead of <code>always @(posedge clk) </code>. This means that now the always block is executed every time clk changes its value, on positive and negative edges. An always block can be triggered by any number of variables. For example, <code>@(clk or d)</code> would trigger it whenever clk or d change. This is used in combinational logic where the output is recalculated whenever an input changes. Back to the example, if <code>clk == 1</code> then the edge is positive. We check it using an if statement. Note that adding the "begin" and "end" keywords is necessary when any block (always, initial, if, for...) has more than one instruction. If omitted for the "if" statement above the second instruction: <code>qn <!-- -->&lt;<!-- -->= !d;</code> would be executed always (it would be ouside of the if statement). These two keywords act like the curly brackets on many programming languages.</p><h3>Tester module</h3><p>This module tests the flip-flop by generating the clock and D signal of the timing diagram above and dumping the Q and QN signals of the flip-flop. It's outputs are the flip-flop's inputs and viceversa.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">flip-flop</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">module tester(q,qn,clk,d);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    input q,qn;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    output clk,d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    reg clk,d;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Run the test once</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    initial</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        clk=0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        //Dump results of the simulation to ff.cvd</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        $dumpfile("dff.vcd");</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        $dumpvars;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        //Generate input signal d</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">           d=0; #9 d=1; #1 d=0; #1 d=1; #2 d=0; #1 d=1; #12 d=0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        #1 d=1; #2 d=0; #1 d=1; #1 d=0; #1 d=1; #1 d=0; # 7 d=1;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        #8 $finish;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Generate periodic clock signal</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    always</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    begin</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        #4 clk=!clk;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">endmodule</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This module is behavioral too as we have initial and always blocks. You should be able to undestand most of the code. However, there are a few new concepts here. The $dumpfile and $dumpvars commands tell the Verilog simulator (more on this ahead) to log the module's variables to the specified file, "dff.vcd" in this case. You may also be wondering what the #s do. These are Verilog delays. The delay the following instruction by a given amount of time. For example, <code>#4 clk=!clk;</code> within an always block changes "clk" every four time units from 0 to 1, producing a square wave. The time unit is a second by default.</p><p>Without using delays there is no way of making the program work. This is the way to control time in the design. You may add delays to any instruction. For example, you could model the flip-flop's delay by adding some to its always block. It's now easy to understand how the <code>d=0; #9 d=1; #1 d=0; #1 d=1; ...</code> lines produce the D signal we want.</p><p>Finally, the $finish command tells the simulator to stop the simulation once the D signal was generated. If this command was omitted the simulation would continue indefinetly because this time the always block has no condition (there is no @ like in the flip-flop module).</p><h3>Testbench module</h3><p>This module just connects the tester module to the flip-flop module:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">module</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">module testbench;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    wire clk,d,q,qn;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    dff ff1(d,clk,q,qn);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    tester tst1(q,qn,clk,d);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">endmodule</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is the most simple of the modules, but it's very different. This time it's structural code, that is, you define the structure of the circuit. It's like describing the circuit diagram. In this case the final circuit is simply the flip-flop connected to the tester. To create a flip flop use <code>dff ff1(d,clk,q,qn);</code>. First goes the module name, followed by the part name, which could be almost any string, followed by the wires that connect to the module in parenthesis. These must follow the order in the module's declaration. In a structural module we use wires. Regs are not necessary because they are defined inside the different modules.</p><h2>Compiling and simulating</h2><p>Go ahead and copy/paste the modules into a text file, order doesn't matter. Call the file "dff.v". The .v extension is standard for Verilog files, but isn't required by the compiler. To compile open a Command Prompt at your working directory (where you saved the file). A quick way to open a command prompt at any directory is to hold shift and right-click the folder, then click "Open Command Window Here". Type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">iverilog -o dff dff.v</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The "-o" tells Icarus Verilog to "save output to the following file". The output is then saved to "dff". This file is not executable. It has to be run using vvp, the Icarus Verilog simulator which is the one that actually produces simulation results, zeros and ones for each of the model variables, as a function of time. To run the simulation type:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">vvp dff</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This is what outputs the dff.vcd file with all the simulation results. However if you open this file with your text editor you'll see it's not easy to understand. To generate an easy-to-understand timing diagram from this file we use GTKWave.</p><p>GTKWave does have a GUI. To open it press Windows key and type "gtkwave". Then click File -<!-- -->&gt;<!-- --> Open New Tab and chose the ffd.vcd file. Now you must add the variables in order to see their timing diagram. Click on "testbench" at the left (SST panel) and then select all the variables using Ctrl or Shift and "Insert" them.</p><p>If everything is okay you should get a timing diagram exactly as the one at the beggining of the tutorial, just like the following:</p><img loading="lazy" class="aligncenter size-large wp-image-143" alt="Icarus Verilog simulation results shown using GTKWave" src="http://localhost:8888/cid/wp-content/uploads/2013/08/simulation2-640x264.png" width="640" height="264"><p>When testing your programs you'll have to go to the compiling-simulating-loading process every few minutes. Remember you can use the up-down arrow keys while in the command prompt to access the last commands and compile/simulate. On GTKWave use File-&gt;Reload Waveform to reload the .vcd file and refresh the timing diagrams without having to reload each variable. By using these tips the whole proccess will take you a few seconds.</p><p>It's over. Now feel free to change the code around to see what happens. Mastering the use of delays, wires and regs takes some time. See <a href="http://www.asic-world.com/verilog/verilog_one_day.html" target="_blank" rel="noopener noreferrer" title="Verilog in One Day">Verilog in One Day</a> for a more in depth explanation of the language.</p>]]></content>
        <author>
            <name>Jose Vargas</name>
            <uri>https://github.com/josedvq</uri>
        </author>
        <category label="icarus" term="icarus"/>
        <category label="verilog" term="verilog"/>
        <category label="windows" term="windows"/>
        <category label="hdl" term="hdl"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Age of Empires 4 closer after new AoE releases]]></title>
        <id>age-of-empires-4-closer</id>
        <link href="https://josedvq.github.io/blog/age-of-empires-4-closer"/>
        <updated>2013-08-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[When will Age of Empires 4 finally be released? Will it be released at all? Those are questions many of us, Age of Empires fans have been wondering for years. Even though the franchise is still owned by Microsoft, no Age of Empires 4 title has been announced. However, after several years of silence, three titles have been announced in the last two years, bringing back hope to the community.]]></summary>
        <content type="html"><![CDATA[<p>When will Age of Empires 4 finally be released? Will it be released at all? Those are questions many of us, Age of Empires fans have been wondering for years. Even though the franchise is still owned by Microsoft, no Age of Empires 4 title has been announced. However, <strong>after several years of silence, three titles have been announced in the last two years</strong>, bringing back hope to the community.</p><h2>Clues of Age of Empires 4</h2><p>Some unnoficial game trailers and many forum threads can be found on the internet but the only official clue we have about a fourth version is the art book apparently included with Age of Empires III Complete Collection:</p><img loading="lazy" class="size-full wp-image-15 aligncenter" alt="Age of Empires 4 art book / brochure" src="http://localhost:8888/cid/wp-content/uploads/2013/08/aoe3.jpg" width="500" height="375"><p>The art book shows five versions. The first three pictures match the three released titles. A game set apparently in World War I or II is foreshadowed as Age of Empires 4 and a game set in the future as the fifth version. This in general has not pleased the AoE community. Most commenters prefer games set in the middle ages as AoE II.</p><h2>Age of Empires alive, Ensemble Studios dead</h2><p>Even after Age of Empires II official servers were shut yeas ago, the 14 year old game is still being played online by other means like GameRanger. There are more AoE II than AoE III players on this service. An unoffical expansion, Age of Empires II - Forgotten Empires was released in December 2012.</p><p>The last AoE expansion and latest title of the saga, Age of Empires III - The Asyan Dynasties was released in October 2007. Almost 6 years later no new titles have been announced. The AoE III community has shrunk over the last years, just alleviated by the release of the game on Steam.</p><p>Ensemble Studios, the studio that created Age of Empires I, II, III and was part of Microsoft,&nbsp;closed in 2009 after releasing Halo Wars. All their projects, none of which was an AoE title, were cancelled. A smaller independent studio called Robot Entertainment was formed with former Ensemble employees. Robot Entertainment was in charge of maintaining AoE III online servers for several years. Later on, Microsoft took over this task.</p><h2>Age of Empires Online: a bad idea</h2><p>Robot Entertainment was initially in charge of developing Age of Empires Online. Gas Powered Games took over the production of this title and kept giving support and content creation for the game until January 2013. This has been, according to metacritic.com, the worst game of the saga with a user score of 5.6/10 and metascore of 7/10:</p><a href="http://www.metacritic.com/search/all/age+of+empires/results" target="_blank" rel="noopener noreferrer"><img loading="lazy" class="size-full wp-image-31 aligncenter" alt="Age of Empires metascores" src="http://localhost:8888/cid/wp-content/uploads/2013/08/aoemeta.png" width="321" height="465"></a><p>It was released on August 2011 as free to play with paid premium content. The business model and pricing were critized. Later on executive producer Kevin Perry pointed out the issues during a speech titled "F2P The Wrong Way". The game system was changed, making it possible to access all premium content without paying. On January 2013 it was announced that no more content would be added because "creating top-tier content, as we have been for the last year and a half, is very expensive... and adding more is no longer cost-effective".</p><img loading="lazy" src="http://localhost:8888/cid/wp-content/uploads/2013/08/aoeo-640x360.jpg" alt="Age of Empires Online screenshot" width="640" height="360" class="img_ev3q"><p>In August 2013 it was announced that the game will remain functional until July 1, 2014 when the Games for Windows - Live servers shut down. The Windows Live Marketplace was shut down meaning no new players can download the game.</p><h2>2013: new activity</h2><p>On a surprising move, Age of Empires II - HD Edition was made available on Steam in April 2013. This somehow followed what a lot of gamers were asking for: another game set in the middle ages, and not in modern ages as the art book suggests. This time Hidden Path Entertainment was in charge. The remake did not meet the expectations of most players. It was criticized due to graphic and multiplayer issues, game crashes and the fact that no new features/corrections were added. What most gamers seem to be waiting for is not a remake, but a new game set in the past with significant gameplay improvements.</p><img loading="lazy" src="http://localhost:8888/cid/wp-content/uploads/2013/08/aoe2hd-640x400.jpg" alt="Age of Empires II HD screenshot" width="640" height="400" class="aligncenter size-large wp-image-45"><p>Age of Empires was announced for iOS and Android in June 2013. It is being developed by KLab (a Japanese studio), to be released on March 2014. It's not the first time AoE goes mobile as Age of Empires - The Age of Kings was released for Nintendo DS in 2006. Age of Empires - The Rise of Rome was also available for now dead Windows Mobile. There has been no serious attempt to take the game to consoles, but there has been speculation on AoE 4 being released for Xbox. It was clarified in the statement that the agreement with KLab was just for a mobile version of the game.</p><h2>Microsoft Games: not a priority</h2><p>Having Age of Empires 4 released soon is definitely not as important to Microsoft as it is to us, fans of the saga. The company is being restructured and it's 'Entertainment and Devices' division represents a very small part of its income:</p><img loading="lazy" src="http://localhost:8888/cid/wp-content/uploads/2013/08/Microsoft-operating-income-by-division-2012-640x409.png" alt="Microsoft-operating-income-by-division-2012" width="640" height="409" class="aligncenter size-large wp-image-264"><p>Even though Microsoft is making money with games, most of it comes from Xbox 360 and not PC game sales. 2013 earnings show similar numbers for this division, with $342 million income for Q3 2013 (fiscal year). PC games have never been a priority for Microsoft. However, <strong>as more and more and more people turn to mobile gaming it is less likely that Microsoft will develop a PC only Age of Empires 4</strong>.</p><h2>The last hope of Age of Empires 4</h2><p>Without Ensemble Studios, the awaited Age of Empires 4 is far. However, it is closer now than two years ago when the franchise showed no signs of life. The addition of three new titles brought back hope of the game being announced soon. It's time for Microsoft to get a hit after AoE Online and AoE II HD failures. If the game is not announced this or next year, it's probably going to be a very long wait for it, if it ever comes.</p><p>Feel free to share your thoughts on this great saga. Which game did you enjoy the most and what do you expect from Age of Empires 4? Will it be announced soon or did it die with Ensemble Studios?</p>]]></content>
        <author>
            <name>Jose Vargas</name>
            <uri>https://github.com/josedvq</uri>
        </author>
        <category label="aoe4" term="aoe4"/>
        <category label="release" term="release"/>
        <category label="videogame" term="videogame"/>
    </entry>
</feed>